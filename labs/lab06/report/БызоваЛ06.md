---
## Front matter
title: "Отчёт по лабораторной работе №6"
subtitle: "Дисциплина: архитектура компьютера"
author: "Бызова Мария Олеговна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Цель данной лабораторной работы - освоение арифметческих инструкций языка ассемблера NASM.

# Теоретическое введение

Большинство инструкций на языке ассемблера требуют обработки операндов. Адрес операнда предоставляет место, где хранятся данные, подлежащие обработке. Это могут быть данные хранящиеся в регистре или в ячейке памяти. 
- Регистровая адресация – операнды хранятся в регистрах и в команде используются имена этих регистров, например: mov ax,bx.
- Непосредственная адресация – значение операнда задается непосредственно в команде, Например: mov ax,2.
- Адресация памяти – операнд задает адрес в памяти. В команде указывается символическое обозначение ячейки памяти, над содержимым которой требуется выполнить операцию.

Ввод информации с клавиатуры и вывод её на экран осуществляется в символьном виде. Кодирование этой информации производится согласно кодовой таблице символов ASCII. ASCII – сокращение от American Standard Code for Information Interchange (Американский стандартный код для обмена информацией). Согласно стандарту ASCII каждый символ кодируется одним байтом.
Среди инструкций NASM нет такой, которая выводит числа (не в символьном виде). Поэтому, например, чтобы вывести число, надо предварительно преобразовать его цифры в ASCII-коды этих цифр и выводить на экран эти коды, а не само число. Если же выводить число на экран непосредственно, то экран воспримет его не как число, а как последовательность ASCII-символов – каждый байт числа будет воспринят как один ASCII-символ – и выведет на экран эти символы.
Аналогичная ситуация происходит и при вводе данных с клавиатуры. Введенные данные будут представлять собой символы, что сделает невозможным получение корректного результата при выполнении над ними арифметических операций.
Для решения этой проблемы необходимо проводить преобразование ASCII символов в числа и обратно

# Выполнение лабораторной работы

## Символьные и численные данные в NASM

1. С помощью утилиты mkdir создаем директорию, в которой будем создавать файлы с программами для лабораторной работы №6. Переходим в созданный каталог с помощью утилиты cd. С помощью утилиты touch создаем файл lab6-1.asm (рис. [-@fig:001]).

![Создание необходимой директории и файла](image/1.png){ #fig:001 width=70% }

2. При помощи Midnight Commander открываем созданный файл lab6-1.asm, вставляем в него программу вывода значения регистра eax, предварительно скопировав в текущий каталог файл in_out.asm, поскольку он небходим для правильной работы программы (рис. [-@fig:002], [-@fig:003]).

![Копирование файла](image/2.png){ #fig:002 width=70% }

![Редактирование файла](image/3.png){ #fig:003 width=70% }

Далее создаем исполняемый файл и запускаем его (рис. [-@fig:004], [-@fig:005]).

![Создание исполняемого файла](image/4.png){ #fig:004 width=70% }

![Запуск исполняемого файла](image/5.png){ #fig:005 width=70% }

Вывод программы: символ j, потому что программа вывела символ, соответствующий по системе ASCII сумме двоичных кодов символов 4 и 6.

3. Далее изменим текст программы и вместо символов, запишем в регистры числа. Исправим текст программы (рис. [-@fig:006]).

![Редактирование файла](image/6.png){ #fig:006 width=70% }

Далее создаем исполняемый файл и запускаем его (рис. [-@fig:007], [-@fig:008]).

![Создание исполняемого файла](image/7.png){ #fig:007 width=70% }

![Запуск исполняемого файла](image/8.png){ #fig:008 width=70% }

Теперь выводится символ с кодом 10 - это символ перевода строки. Этот символ не отображается при выводе на экран.

4. Создадим новый файл lab6-2.asm с помощью утилиты touch (рис. [-@fig:009]).

![Создание файла](image/9.png){ #fig:009 width=70% }

Вводим в файл текст другой программы для вывода значения регистра eax (рис. [-@fig:010]).

![Редактирование файла](image/10.png){ #fig:010 width=70% }

Далее создаем исполняемый файл и запускаем его (рис. [-@fig:011], [-@fig:012]).

![Создание исполняемого файла](image/11.png){ #fig:011 width=70% }

![Запуск исполняемого файла](image/12.png){ #fig:012 width=70% }

В результате работы программы мы получим число 106. В данном случае, как и в первом, команда add складывает коды символов ‘6’ и ‘4’ (54+52=106). Однако, в отличии от программы из листинга 6.1, функция iprintLF позволяет вывести число, а не символ, кодом которого является это число.

5. Заменяем в тексте программы в файле lab6-2.asm символы "6" и "4" на числа 6 и 4 (рис. [-@fig:013]).

![Редактирование файла](image/13.png){ #fig:013 width=70% }

Далее создаем исполняемый файл и запускаем его (рис. [-@fig:014], [-@fig:015]).

![Создание исполняемого файла](image/14.png){ #fig:011 width=70% }

![Запуск исполняемого файла](image/15.png){ #fig:012 width=70% }

Теперь программа складывает не соответствующие символам коды в системе ASCII, а сами числа, поэтому вывод 10.

Заменяем в тексте программы функцию iprintLF на iprint (рис. [-@fig:016]).

![Редактирование файла](image/16.png){ #fig:016 width=70% } 

Далее создаем исполняемый файл и запускаем его (рис. [-@fig:017], [-@fig:018]).

![Создание исполняемого файла](image/17.png){ #fig:017 width=70% }

![Запуск исполняемого файла](image/18.png){ #fig:018 width=70% }

Вывод не изменился, потому что символ переноса строки не отображался, когда программа исполнялась с функцией iprintLF, а iprint не добавляет к выводу символ переноса строки, в отличие от iprintLF.

## Выполнение арифметических операций в NASM

6. Создаем файл lab6-3.asm с помощью утилиты touch (рис. [-@fig:019]).

![Создание файла](image/19.png){ #fig:019 width=70% }

Вводим в созданный файл текст программы для вычисления значения выражения f(x) = (5 * 2 + 3)/3 (рис. [-@fig:020]).

![Редактирование файла](image/20.png){ #fig:020 width=70% }

Далее создаем исполняемый файл и запускаем его (рис. [-@fig:021], [-@fig:022]).

![Создание исполняемого файла](image/21.png){ #fig:021 width=70% }

![Запуск исполняемого файла](image/22.png){ #fig:022 width=70% }

Изменяем программу так, чтобы она вычисляла значение выражения f(x) = (4 * 6 + 2)/5 (рис. [-@fig:023]). 

![Изменение программы](image/23.png){ #fig:023 width=70% }

Далее создаем исполняемый файл и запускаем его (рис. [-@fig:024]).

![Запуск исполняемого файла](image/24.png){ #fig:024 width=70% }

Посчитаем для проверки правильности работы программы значение выражения самостоятельно, программа отработала верно.

7. Создадим файл variant.asm с помощью  утилиты touch (рис. [-@fig:025]).

![Создание файла](image/25.png){ #fig:025 width=70% }

Вводим в файл текст программы для вычисления варианта задания по номеру студенческого билета (рис. [-@fig:026]).

![Редактирование файла](image/26.png){ #fig:026 width=70% }

Создаем и запускаем исполняемый файл (рис. [-@fig:027]). Вводим номер своего студ. билета с клавиатуры, программа вывела, что мой вариант - 10.(рис. [-@fig:028]).

![Создание исполняемого файла](image/27.png){ #fig:027 width=70% }

![Запуск исполняемого файла](image/28.png){ #fig:028 width=70% }

### Ответы на вопросы по программе

1. За вывод сообщения "Ваш вариант" отвечают строки кода:

```NASM
mov eax,rem
call sprint
```

2. Инструкция mov ecx, x используется, чтобы положить адрес вводимой строки x в регистр ecx. 
Инструкция mov edx, 80 используется для записи в регистр edx длины вводимой строки 
Инструкция call sread используется для вызова подпрограммы из внешнего файла, обеспечивающей ввод сообщения с клавиатуры.

3. Инструкция call atoi используется для вызова подпрограммы из внешнего файла, которая преобразует ascii-код символа в целое число и записывает результат в регистр eax

4. За вычисления варианта отвечают строки:

```NASM
xor edx,edx ; обнуление edx для корректной работы div
mov ebx,20 ; ebx = 20
div ebx ; eax = eax/20, edx - остаток от деления
inc edx ; edx = edx + 1
```
5. При выполнении инструкции div ebx остаток от деления записывается в регистр edx

6. Инструкция inc edx увеличивает значение регистра edx на 1

7. За вывод на экран результатов вычислений отвечают строки:

```NASM
mov eax,edx
call iprintLF
```
# Выполнение заданий для самостоятельной работы

1. Создаем файл lab6-4.asm с помощью утилиты touch (рис. [-@fig:029]).

![Создание файла](image/29.png){ #fig:029 width=70% }

Открываем созданный файл для редактирования, вводим в него текст программы для вычисления значения выражения 5 * (х + 18) - 28 (рис. [-@fig:030]). Это выражение было под вариантом 10.

![Написание программы](image/30.png){ #fig:030 width=70% }

Далее создаем исполняемый файл и запускаем его (рис. [-@fig:031], [-@fig:032]).

![Создание исполняемого файла](image/31.png){ #fig:031 width=70% }

![Запуск исполняемого файла](image/32.png){ #fig:032 width=70% }

При вводе значения 2, вывод - 72. Проводим еще один запуск исполняемого файла для проверки работы программы с другим значением на входе (рис. [-@fig:033]). Программа отработала верно.

![Запуск исполняемого файла](image/33.png){ #fig:033 width=70% }


**Листинг. Программа для вычисления значения выражения 5 * (х + 18) - 28.**

```NASM
%include 'in_out.asm' ; подключение внешнего файла
SECTION .data ; секция инициированных данных
msg: DB 'Введите значение переменной х: ',0
rem: DB 'Результат: ',0
SECTION .bss ; секция не инициированных данных
x: RESB 80 ; Переменная, значение к-рой будем вводить с клавиатуры, выделенный размер - 80 байт
SECTION .text ; Код программы
GLOBAL _start ; Начало программы
_start: ; Точка входа в программу
; ---- Вычисление выражения
mov eax, msg ; запись адреса выводимиого сообщения в eax
call sprint ; вызов подпрограммы печати сообщения
mov ecx, x ; запись адреса переменной в ecx
mov edx, 80 ; запись длины вводимого значения в edx
call sread ; вызов подпрограммы ввода сообщения
mov eax,x ; вызов подпрограммы преобразования
call atoi ; ASCII кода в число, `eax=x`
add eax,18;
mov ebx,5;
mul ebx;
add eax,-28;
mov edi,eax ; запись результата вычисления в 'edi'
; ---- Вывод результата на экран
mov eax,rem ; вызов подпрограммы печати
call sprint ; сообщения 'Результат: '
mov eax,edi ; вызов подпрограммы печати значения
call iprint ; из 'edi' в виде символов
call quit ; вызов подпрограммы завершения
```

# Выводы

При выполнении данной лабораторной работы я освоила арифметические инструкции языка ассемблера NASM.

::: {#refs}
:::

