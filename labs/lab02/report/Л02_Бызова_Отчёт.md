---
## Front matter
title: "Отчёт по лабораторной работе №2"
subtitle: "Дисциплина: Архитектура компьютера"
author: "Бызова Мария Олеговна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Целью данной лабораторной работы является изучение идеологии и применение средств
контроля версий, приобретение практических навыков по работе с системой git.

# Теоретическое введение

Системы контроля версий (Version Control System, VCS) применяются при работе нескольких
человек над одним проектом. Обычно основное дерево проекта хранится в локальном или
удалённом репозитории, к которому настроен доступ для участников проекта. При внесении
изменений в содержание проекта система контроля версий позволяет их фиксировать,
совмещать изменения, произведённые разными участниками проекта, производить откат к
любой более ранней версии проекта, если это требуется. В классических системах контроля
версий используется централизованная модель, предполагающая наличие единого
репозитория для хранения файлов. Выполнение большинства функций по управлению
версиями осуществляется специальным сервером. Участник проекта (пользователь) перед
началом работы посредством определённых команд получает нужную ему версию файлов.
После внесения изменений пользователь размещает новую версию в хранилище. При этом
предыдущие версии не удаляются из центрального хранилища и к ним можно вернуться в
любой момент. Сервер может сохранять не полную версию изменённых файлов, а
производить так называемую дельта-компрессию — сохранять только изменения между
последовательными версиями, что позволяет уменьшить объём хранимых данных. Системы
контроля версий поддерживают возможность отслеживания и разрешения конфликтов,
которые могут возникнуть при работе нескольких человек над одним файлом. Можно
объединить изменения, сделанные разными участниками, вручную выбрать нужную версию,
отменить изменения вовсе или заблокировать файлы для изменения. В зависимости от
настроек блокировка не позволяет 7 другим пользователям получить рабочую копию или
препятствует изменению рабочей копии файла средствами файловой системы ОС,
обеспечивая таким образом привилегированный доступ только одному пользователю,
работающему с файлом. Системы контроля версий также могут обеспечивать
дополнительные, более гибкие функциональные возможности. Например, они могут
поддерживать работу с несколькими версиями одного файла, сохраняя общую историю
изменений до точки ветвления версий и собственные истории изменений каждой ветви.
Обычно доступна информация о том, кто из участников, когда и какие изменения вносил.
Обычно такого рода информация хранится в журнале изменений, доступ к которому можно
ограничить. В отличие от классических, в распределённых системах контроля версий
центральный репозиторий не является обязательным. Среди классических VCS наиболее
известны CVS, Subversion, а среди распределённых — Git, Bazaar, Mercurial. Принципы их
работы схожи, отличаются они в основном синтаксисом используемых в работе команд.
Система контроля версий Git представляет собой набор программ командной строки. Доступ
к ним можно получить из терминала посредством ввода команды git с различными опциями.
Благодаря тому, что Git является распределённой системой контроля версий, резервную
копию локального хранилища можно сделать простым копированием или архивацией. Работа
пользователя со своей веткой начинается с проверки и получения изменений из центрального
репозитория (при этом в локальное дерево до начала этой процедуры не должно было
вноситься изменений). Затем можно вносить изменения в локальном дереве и/или ветке.
После завершения внесения какого-то изменения в файлы и/или каталоги проекта
необходимо разместить их в центральном репозитории.

# Выполнение лабораторной работы

## 1. Настройка Github.

Чтобы приступить к настройке, зайдя через браузер на сайт GitHub, создаем учетную запись
или входим в ранее уже созданную. При необходимости заполняем основные данные. Для
выполнения лабораторной работы я воспользуюсь ранее созданной учетной записью. (рис. 1-
3 @fig:001 @fig:002 @fig:003)

[Рисунок 1. Главная страница сайта Github.](image/1.jpeg){#fig:001 width=70%}
[Рисунок 2. Вход в ранее созданный аккаунт.](image/2.jpeg){#fig:002 width=70%}
[Рисунок 3. Аккаунт Github.](image/3.jpeg){#fig:003 width=70%}

## 2. Базовая настройка Git.

Для дальнейшей настройки Git открываем терминал и вводим следующие команды: команду
git config –global user.name “”, указывая свое имя, и команду git config –global user.email
“work@mail”, указывая в ней электронную почту владельца репозитория (рис. 4 @fig:004).

[Рисунок 4. Предварительная конфигурация git.](image/4.jpeg){#fig:004 width=70%}

Настраиваем utf-8 в выводе сообщений git для корректного отображения символов (рис. 5 @fig:005).

[Рисунок 5. Настройка кодировки](image/5.jpeg){#fig:005 width=70%}

Далее зададим имя начальной ветки. Назовём её «master» (рис. 6 @fig:006)

[Рисунок 6. Создание имени для начальной ветки.](image/6.jpeg){#fig:006 width=70%}

Зададим параметр autocrlf со значением input для того, чтобы конвертировать CRLF в LF
только при коммитах. Уточним, что CR и LF – это символы, которые можно использовать для
обозначения разрыва строки в текстовых файлах (рис. 7 @fig:007)

[Рисунок 7. Параметр autocrlf.](image/7.jpeg){#fig:007 width=70%}
 
Далее зададим параметр safecrlf со значением warn. Таким образом, Git будет проверять
преобразование на обратимость. В дальнейшей работе при значении warn Git только выведет
предупреждение, но будет принимать необратимые конвертации (рис. 8 @fig:008).

[Рисунок 8. Параметр safecrlf.](image/8.jpeg){#fig:008 width=70%}

## 3. Создание SSH ключа.

Для последующей идентификации пользователя на сервере репозиториев необходимо
сгенерировать пару ключей (приватный и открытый). Для этого вводим команду ssh-keygen -
C “Имя Фамилия, work@email”, указывая имя владельца и электронную почту владельца.
Ключ автоматически сохранится в каталоге ~/.ssh/ (рис. 9 @fig:009).

[Рисунок 9 . Создание SSH-ключа.](image/9.jpeg){#fig:009 width=70%}

Далее копируем открытый ключ из директории, в которой он был сохранен, с помощью
утилиты xclip (рис. 10 @fig:010).

[Рисунок 10. Копирование содержимого файла.](image/10.jpeg)){#fig:010 width=70%}

Далее необходимо загрузить сгенерённый открытый ключ. Для этого заходим на сайт http:
//github.org/ под своей учётной записью и переходим в меню Setting. После этого выбираем в
боковом меню SSH and GPG keys и нажимаем кнопку New SSH key. Вставляем ключ в
появившееся на сайте поле и указываем для ключа имя (Title). Нажимаем «Add SSH-key»,
чтобы завершить добавление ключа (рис. 11 @fig:011).

[Рисунок 11. Добавление ключа.](image/11.jpeg){#fig:011 width=70%}

## 4. Создание рабочего пространства и репозитория курса на основе шаблона.

После проделанных действий возвращаемся в терминал. Создаём каталог для предмета
«Архитектура компьютера» с помощью утилиты mkdir с ключом -p. Далее проверяем работу
команды (рис. 12-13 @fig:012 @fig:013) любым удобным способом.

[Рисунок 12. Создание рабочего пространства.](image/12.jpeg){#fig:012 width=70%}
[Рисунок 13. Проверка работы команды.](image/13.jpeg){#fig:013 width=70%}

## 5. Создание репозитория курса на основе шаблона.

Далее в браузере переходим на страницу репозитория с шаблоном курса по адресу
https://github.com/yamadharma/course-directory-student-template. Теперь выбираем «Use this
template», чтобы использовать этот шаблон для своего репозитория (рис. 14 @fig:014).

[Рисунок 14. Страница шаблона для репозитория.](image/14.jpeg){#fig:014 width=70%}

В открывшемся окне задаем имя репозитория (Repository name) «study_2023–2024_arh-pc» и
создаем репозиторий (кнопка Create repository from template) (рис. 15 @fig:015).

[Рисунок 15. Окно создания репозитория.](image/15.jpeg){#fig:015 width=70%}

Таким образом, репозиторий успешно создан (рис. 16 @fig:016).

[Рисунок 16. Созданный репозиторий.](image/16.jpeg){#fig:016 width=70%}

Для дальнейшей работы через терминал переходим в созданный каталог курса с помощью уже
известной нам утилиты cd (рис. 17 @fig:017).

[Рисунок 17. Перемещение между директориями.](image/17.jpeg){#fig:017 width=70%}

Теперь клонируем созданный репозиторий с помощью команды git clone –recursive
git@github.com:/study_2023–2024_arh-pc.git arch-pc, предварительно скопировав ссылку для
клонирования на странице созданного репозитория: сначала переходим в окно «code», далее
выбираем в окне вкладку «SSH» (рис. 18-19 @fig:018 @fig:019).

[Рисунок 18. Окно с ссылкой для копирования репозитория.](image/18jpeg){#fig:018 width=70%}
[Рисунок 19. Клонирование репозитория.](image/19.jpeg){#fig:019 width=70%}

Таким образом, репозиторий успешно скопирован.

## 6. Настройка каталога курса.

Для дальнейшей работы переходим в каталог курса с помощью утилиты cd (рис. 20 @fig:020).

[Рисунок 20. Перемещение между директориями.](image/20.png){#fig:020 width=70%}

Теперь удалим лишние файлы с помощью утилиты rm (рис. 21 @fig:021).(image/21.png){#fig:001 width=70%}

[Рисунок 21. Удаление файлов.](image/21.png){#fig:021 width=70%}

Создадим все необходимые каталоги при помощи ряда команд (рис. 22 @fig:022).

[Рисунок 22. Создание каталогов.](image/22.jpeg){#fig:022 width=70%}

Отправим созданные нами каталоги на наш сервер с локального репозитория: для этого
добавляем все созданные ранее каталоги при помощи git add, комментируем и сохраняем
изменения на сервере как добавление курса с помощью git commit (рис. 23 @fig:023).

[Рисунок 23. Добавление и сохранение изменений на сервере.](image/23.jpeg){#fig:023 width=70%}

При помощи push отправляем всё на сервер (рис. 24 @fig:024).

[Рисунок 24. Выгрузка изменений на сервер.](image/24.jpeg){#fig:024 width=70%}

В конце концов проверим правильность создания иерархии рабочего пространства в
локальном репозитории и на странице github (рис. 25-26 @fig:025 @fig:026).

[Рисунок 25. Страница репозитория (1).](image/25.jpeg){#fig:025 width=70%}
[Рисунок 26. Страница репозитория (2).](image/26.jpeg){#fig:026 width=70%}

# Описание результатов выполнения заданий для самостоятельной работы.
1. Для создания отчета по выполнению лабораторной работы в соответствующем каталоге
рабочего пространства переходим в директорию labs/lab02/report с помощью утилиты cd.
Создаем в каталоге файл для отчета по второй лабораторной работе с помощью утилиты
touch (рис. 27-28 @fig:027 @fig:028).

[Рисунок 27. Перемещение между директориями.](image/27.jpeg){#fig:027 width=70%}
[Рисунок 28. Создание файла.](image/28.png){#fig:028 width=70%}

2. Для копирования отчетов по выполнению предыдущих лабораторных работ в
соответствующие каталоги созданного рабочего пространства проверим местонахождение
файла с отчетом по первой лабораторной работе - он должен находиться в подкаталоге
домашней директории «Загрузки», для проверки используем команду ls (рис. 29 @fig:029). Затем
копируем необходимый файл с помощью утилиты cp (рис. 30 @fig:030). Проверяем правильность
выполнения команды cp с помощью ls (рис. 31 @fig:031).

[Рисунок 29. Проверка местонахождения файла.](image/29.jpeg){#fig:029 width=70%}
[Рисунок 30. Копирование файл.](image/30.jpeg){#fig:030 width=70%}
[Рисунок 31. Проверка выполнения команды.](image/31.jpeg){#fig:031 width=70%}

3. Далее с помощью ранее изученных команд загружаем файлы на GitHub: добавляем с
помощью git add нужный файл, сохраняем изменения с помощью git commit, отправляем в
центральный репозиторий сохраненные изменения командой git push. Проверяем
правильность работы (рис. 32-35 @fig:032 @fig:033 @fig:034 @fig:035).

[Рисунок 32. Загрузка файла с отчетом по лабораторной работе №1 на GitHub.](image/32.jpeg){#fig:032 width=70%}
[Рисунок 33. Проверка правильности работы команд.](image/33.jpeg){#fig:033 width=70%}
[Рисунок 34. Загрузка файла с отчетом по лабораторной работе №2 на GitHub.](image/34.jpeg){#fig:034 width=70%}
[Рисунок 35. Проверка правильности работы команд.](image/35.jpeg){#fig:035 width=70%}

Мы видим, что пояснение к совершенным действиям отображается, а отчеты по лабораторным
работам находятся в соответствующих каталогах репозитория: отчет по первой - в lab01/report,
по второй – в lab02/report. Убеждаемся, что всё выполнено верно.

# Выводы

В ходе выполнения данной лабораторной работы были получены практические навыки
работы с системой git, а также была изучена идеология и применение средств контроля
версий посредству выполнения различных заданий, а именно:
1. Настройки GitHub.
2. Базовой настройки Git.
3. Создания SSH-ключа.
4. Создания рабочего пространства и репозитория курса на основе шаблона.
5. Создания репозитория курса на основе шаблона.
6. Настройки каталога курса.
7. Выполнения заданий для самостоятельной работы для подведения итогов и закрепления
полученных знаний.
